<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="HPKE ü§ù hacspec"><meta name="keywords" content="rust, rustlang, rust-lang, hpke"><title>hpke - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../hpke/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../hpke/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate hpke</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../hpke/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">hpke</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/hpke/hpke.rs.html#1-990">source</a> ¬∑ <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="hpke--hacspec"><a href="#hpke--hacspec">HPKE ü§ù hacspec</a></h2>
<blockquote>
<p>üí° This is a hacspec representation of the <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-hpke/">HPKE RFC</a>.
The text is mostly verbatim from the RFC with changes where required.
It demonstrates the possibilities of hacspec for specifications.</p>
</blockquote>
<p>This document describes a scheme for hybrid public-key encryption (HPKE).
This scheme provides a variant of public-key encryption of arbitrary-sized
plaintexts for a recipient public key. It also includes three authenticated
variants, including one which authenticates possession of a pre-shared key,
and two optional ones which authenticate possession of a KEM private key.
HPKE works for any combination of an asymmetric key encapsulation mechanism
(KEM), key derivation function (KDF), and authenticated encryption with
additional data (AEAD) encryption function. Some authenticated variants may not
be supported by all KEMs. We provide instantiations of the scheme using widely
used and efficient primitives, such as Elliptic Curve Diffie-Hellman key
agreement, HKDF, and SHA2.</p>
<p>The original document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</p>
<h2 id="introduction"><a href="#introduction">Introduction</a></h2>
<p>Encryption schemes that combine asymmetric and symmetric algorithms have been
specified and practiced since the early days of public-key cryptography, e.g.,
<a href="https://datatracker.ietf.org/doc/rfc1421/">RFC1421</a>. Combining the two yields the key management advantages of asymmetric
cryptography and the performance benefits of symmetric cryptography. The traditional
combination has been ‚Äúencrypt the symmetric key with the public key.‚Äù ‚ÄúHybrid‚Äù
public-key encryption schemes (HPKE), specified here, take a different approach:
‚Äúgenerate the symmetric key and its encapsulation with the public key.‚Äù
Specifically, encrypted messages convey an encryption key encapsulated with a
public-key scheme, along with one or more arbitrary-sized ciphertexts encrypted
using that key. This type of public key encryption has many applications in
practice, including Messaging Layer Security <a href="https://datatracker.ietf.org/doc/draft-ietf-mls-protocol/">mls-protocol</a> and
TLS Encrypted ClientHello <a href="https://datatracker.ietf.org/doc/draft-ietf-tls-esni/">tls-esni</a>.</p>
<p>Currently, there are numerous competing and non-interoperable standards and
variants for hybrid encryption, mostly based on ECIES, including <a href="https://webstore.ansi.org/Standards/ASCX9/ANSIX9632011R2017">ANSI X9.63 (ECIES)</a>,
<a href="https://standards.ieee.org/standard/1363a-2004.html">IEEE1363</a>, <a href="https://webstore.iec.ch/publication/10633&amp;preview=1">ISO/IEC 18033-2</a>, and <a href="https://secg.org/sec1-v2.pdf">SECG SEC 1</a>.
See <a href="https://ieeexplore.ieee.org/abstract/document/5604194/">MAEA10</a> for a thorough comparison. All these existing
schemes have problems, e.g., because they rely on outdated primitives, lack
proofs of IND-CCA2 security, or fail to provide test vectors.</p>
<p>This document defines an HPKE scheme that provides a subset
of the functions provided by the collection of schemes above, but
specified with sufficient clarity that they can be interoperably
implemented. The HPKE construction defined herein is secure against (adaptive)
chosen ciphertext attacks (IND-CCA2 secure) under classical assumptions about
the underlying primitives <a href="https://eprint.iacr.org/2020/243">HPKEAnalysis</a>, <a href="https://eprint.iacr.org/2020/1499">ABHKLR20</a>. A summary of
these analyses is in Section 9.1.</p>
<p>This document represents the consensus of the Crypto Forum Research Group (CFRG).</p>
<h2 id="notation"><a href="#notation">Notation</a></h2>
<p>The following terms are used throughout this document to describe the
operations, roles, and behaviors of HPKE:</p>
<ul>
<li><code>(skX, pkX)</code>: A Key Encapsulation Mechanism (KEM) key pair used in role X,
where X is one of S, R, or E as sender, recipient, and ephemeral, respectively;
<code>skX</code> is the private key and <code>pkX</code> is the public key.</li>
<li><code>pk(skX)</code>: The KEM public key corresponding to the KEM private key <code>skX</code>.</li>
<li>Sender (S): Role of entity which sends an encrypted message.</li>
<li>Recipient (R): Role of entity which receives an encrypted message.</li>
<li>Ephemeral (E): Role of a fresh random value meant for one-time use.</li>
<li><code>I2OSP(n, w)</code>: Convert non-negative integer <code>n</code> to a <code>w</code>-length,
big-endian byte string as described in <a href="https://datatracker.ietf.org/doc/rfc8017/">RFC8017</a>.</li>
<li><code>OS2IP(x)</code>: Convert byte string <code>x</code> to a non-negative integer as
described in <a href="https://datatracker.ietf.org/doc/rfc8017/">RFC8017</a>, assuming big-endian byte order.</li>
<li><code>concat(x0, ..., xN)</code>: Concatenation of byte strings.
<code>concat(0x01, 0x0203, 0x040506) = 0x010203040506</code>.</li>
<li><code>random(n)</code>: A pseudorandom byte string of length <code>n</code> bytes</li>
<li><code>xor(a,b)</code>: XOR of byte strings; <code>xor(0xF0F0, 0x1234) = 0xE2C4</code>.
It is an error to call this function with two arguments of unequal
length.</li>
</ul>
<h2 id="cryptographic-dependencies"><a href="#cryptographic-dependencies">Cryptographic Dependencies</a></h2>
<p>HPKE variants rely on the following primitives:</p>
<ul>
<li>A Key Encapsulation Mechanism (<a href="../hpke_kem/index.html">KEM</a>)</li>
<li>A Key Derivation Function (<a href="../hpke_kdf/index.html">KDF</a>)</li>
<li>An <a href="../hpke_aead/index.html">AEAD</a> encryption algorithm <a href="https://www.rfc-editor.org/info/rfc5116">RFC5116</a></li>
</ul>
<p>A <em>ciphersuite</em> is a triple (KEM, KDF, AEAD) containing a choice of algorithm
for each primitive.</p>
<p>A set of algorithm identifiers for concrete instantiations of these
primitives is provided in <a href="../hpke_kem/enum.KEM.html">KEM</a>, <a href="../hpke_kdf/enum.KDF.html">KDF</a>, and <a href="../hpke_aead/enum.AEAD.html">AEAD</a>.
Algorithm identifier values are two bytes long.
Future specifications may introduce new KEM, KDF, and AEAD algorithm
identifiers and retain the security guarantees presented in this document.</p>
<p>Note that <a href="../hpke_kem/fn.GenerateKeyPair.html" title="GenerateKeyPair"><code>GenerateKeyPair</code></a> can be implemented as <a href="../hpke_kem/fn.DeriveKeyPair.html"><code>DeriveKeyPair(random(Nsk))</code></a>.</p>
<p>The notation <code>pk(skX)</code>, depending on its use and the KEM and its
implementation, is either the
computation of the public key using the private key, or just syntax
expressing the retrieval of the public key assuming it is stored along
with the private key object.</p>
<h2 id="hybrid-public-key-encryption"><a href="#hybrid-public-key-encryption">Hybrid Public Key Encryption</a></h2>
<p>In this section, we define a few HPKE variants. All variants take a
recipient public key and a sequence of plaintexts <code>pt</code>, and produce an
encapsulated key <code>enc</code> and a sequence of ciphertexts <code>ct</code>. These outputs are
constructed so that only the holder of <code>skR</code> can decapsulate the key from
<code>enc</code> and decrypt the ciphertexts. All the algorithms also take an
<code>info</code> parameter that can be used to influence the generation of keys
(e.g., to fold in identity information) and an <code>aad</code> parameter that
provides Additional Authenticated Data to the <a href="../hpke_aead/enum.AEAD.html" title="AEAD"><code>AEAD</code></a> algorithm in use.</p>
<p>In addition to the base case of encrypting to a public key, we
include three authenticated variants, one which authenticates
possession of a pre-shared key, one which authenticates
possession of a <a href="../hpke_kem/index.html">KEM</a> private key, and one which authenticates possession of both
a pre-shared key and a <a href="../hpke_kem/index.html">KEM</a> private key. All authenticated variants contribute
additional keying material to the encryption operation. The following one-byte
values will be used to distinguish between modes:</p>
<div><table><thead><tr><th style="text-align: left">Mode</th><th style="text-align: left">Value</th></tr></thead><tbody>
<tr><td style="text-align: left">mode_base</td><td style="text-align: left">0x00</td></tr>
<tr><td style="text-align: left">mode_psk</td><td style="text-align: left">0x01</td></tr>
<tr><td style="text-align: left">mode_auth</td><td style="text-align: left">0x02</td></tr>
<tr><td style="text-align: left">mode_auth_psk</td><td style="text-align: left">0x03</td></tr>
</tbody></table>
</div>
<p>All these cases follow the same basic two-step pattern:</p>
<ol>
<li>Set up an encryption context that is shared between the sender
and the recipient.</li>
<li>Use that context to encrypt or decrypt content.</li>
</ol>
<p>A <em>context</em> is an implementation-specific structure that encodes
the AEAD algorithm and key in use, and manages the nonces used so
that the same nonce is not used with multiple plaintexts. It also
has an interface for exporting secret values, as described in
<a href="fn.Context_Export.html" title="Context_Export"><code>Context_Export</code></a>. See <a href="fn.ContextS_Seal.html">HPKE DEM</a> for a description of this structure
and its interfaces. HPKE decryption fails when the underlying AEAD
decryption fails.</p>
<p>The constructions described here presume that the relevant non-private
parameters (<code>enc</code>, <code>psk_id</code>, etc.) are transported between the sender and the
recipient by some application making use of HPKE. Moreover, a recipient with more
than one public key needs some way of determining which of its public keys was
used for the encapsulation operation. As an example, applications may send this
information alongside a ciphertext from sender to recipient. Specification of
such a mechanism is left to the application. See <a href="#message-encoding">Message Encoding</a> for more
details.</p>
<p>Note that some KEMs may not support <a href="../hpke_kem/fn.AuthEncap.html" title="AuthEncap()"><code>AuthEncap()</code></a> or <a href="../hpke_kem/fn.AuthDecap.html" title="AuthDecap()"><code>AuthDecap()</code></a>.
For such KEMs, only <code>mode_base</code> or <code>mode_psk</code> are supported. Future specifications
which define new KEMs MUST indicate whether these modes are supported.
See <a href="../hpke_kem/index.html#future-kems">Future KEMs</a> for more details.</p>
<p>The procedures described in this section are laid out in a
Python-like pseudocode. The algorithms in use are left implicit.
See the <a href="#hacspec-implementation-considerations">Implementation Considerations Section</a>
for details on the differences to this hacspec implementation.</p>
<h3 id="creating-the-encryption-context"><a href="#creating-the-encryption-context">Creating the Encryption Context</a></h3>
<p>The variants of HPKE defined in this document share a common
key schedule that translates the protocol inputs into an encryption
context.</p>
<p>See <a href="fn.KeySchedule.html" title="KeySchedule()"><code>KeySchedule()</code></a> for details.</p>
<h4 id="encryption-to-a-public-key"><a href="#encryption-to-a-public-key">Encryption to a Public Key</a></h4>
<p>The most basic function of an HPKE scheme is to enable encryption
to the holder of a given KEM private key.</p>
<p>See <a href="fn.SetupBaseS.html" title="SetupBaseS()"><code>SetupBaseS()</code></a> and <a href="fn.SetupBaseR.html" title="SetupBaseR()"><code>SetupBaseR()</code></a> for details.</p>
<h4 id="authentication-using-a-pre-shared-key"><a href="#authentication-using-a-pre-shared-key">Authentication using a Pre-Shared Key</a></h4>
<p>This variant extends the base mechanism by allowing the recipient to
authenticate that the sender possessed a given PSK.</p>
<p>See <a href="fn.SetupPSKS.html" title="SetupPSKS()"><code>SetupPSKS()</code></a> and <a href="fn.SetupPSKR.html" title="SetupPSKR()"><code>SetupPSKR()</code></a> for details.</p>
<h4 id="authentication-using-an-asymmetric-key"><a href="#authentication-using-an-asymmetric-key">Authentication using an Asymmetric Key</a></h4>
<p>This variant extends the base mechanism by allowing the recipient
to authenticate that the sender possessed a given KEM private key.</p>
<p>See <a href="fn.SetupAuthS.html" title="SetupAuthS()"><code>SetupAuthS()</code></a> and <a href="fn.SetupAuthR.html" title="SetupAuthR()"><code>SetupAuthR()</code></a> for details.</p>
<h4 id="authentication-using-both-a-psk-and-an-asymmetric-key"><a href="#authentication-using-both-a-psk-and-an-asymmetric-key">Authentication using both a PSK and an Asymmetric Key</a></h4>
<p>This mode is a straightforward combination of the PSK and
authenticated modes.</p>
<p>See <a href="fn.SetupAuthPSKS.html" title="SetupAuthPSKS()"><code>SetupAuthPSKS()</code></a> and <a href="fn.SetupAuthPSKR.html" title="SetupAuthPSKR()"><code>SetupAuthPSKR()</code></a> for details.</p>
<h3 id="encryption-and-decryption"><a href="#encryption-and-decryption">Encryption and Decryption</a></h3>
<p>HPKE allows multiple encryption operations to be done based on a
given setup transaction.</p>
<p>See <a href="fn.ContextS_Seal.html" title="ContextS_Seal"><code>ContextS_Seal</code></a> and <a href="fn.ContextR_Open.html" title="ContextR_Open"><code>ContextR_Open</code></a> for details.</p>
<h3 id="secret-export"><a href="#secret-export">Secret Export</a></h3>
<p>HPKE provides an interface for exporting secrets from the encryption context
using a variable-length PRF, similar to the TLS 1.3 exporter interface.</p>
<p>See <a href="fn.Context_Export.html" title="Context_Export"><code>Context_Export</code></a> for details.</p>
<h2 id="single-shot-apis"><a href="#single-shot-apis">Single-Shot APIs</a></h2><h3 id="encryption-and-decryption---single-shot"><a href="#encryption-and-decryption---single-shot">Encryption and Decryption - Single-Shot</a></h3>
<p>In many cases, applications encrypt only a single message to a recipient‚Äôs public key.</p>
<p>See <a href="fn.HpkeSeal.html" title="HpkeSeal"><code>HpkeSeal</code></a> and <a href="fn.HpkeOpen.html" title="HpkeOpen"><code>HpkeOpen</code></a> for details.</p>
<h3 id="secret-export---single-shot"><a href="#secret-export---single-shot">Secret Export - Single-Shot</a></h3>
<p>Applications may also want to derive a secret known only to a given recipient.
This section provides templates for HPKE APIs that implement stateless
‚Äúsingle-shot‚Äù secret export using APIs specified in <a href="#secret-export">Secret Export</a>:</p>
<p>See <a href="fn.SendExport.html" title="SendExport"><code>SendExport</code></a> and <a href="fn.ReceiveExport.html" title="ReceiveExport"><code>ReceiveExport</code></a>.</p>
<p>As in <a href="#encryption-and-decryption---single-shot">Single Shot Encryption</a>, the <code>MODE</code> template parameter is one of Base, PSK,
Auth, or AuthPSK. The optional parameters indicated by ‚Äú‚Ä¶‚Äù depend on <code>MODE</code> and may
be empty.</p>
<h2 id="algorithm-identifiers"><a href="#algorithm-identifiers">Algorithm Identifiers</a></h2>
<p>This section lists algorithm identifiers suitable for different HPKE configurations.
Future specifications may introduce new KEM, KDF, and AEAD algorithm identifiers
and retain the security guarantees presented in this document provided they adhere
to the security requirements in <a href="../hpke_kem/index.html#security-requirements-on-a-kem-used-within-hpke">KEM Security</a>, <a href="../hpke_kdf/index.html#security-requirements-on-a-kdf">KDF Security</a>, and
<a href="../hpke_aead/index.html#security-requirements-on-an-aead">AEAD Security</a>, respectively.</p>
<p>See <a href="../hpke_kdf/index.html">KDF</a>, <a href="../hpke_kem/index.html">KEM</a>, and <a href="../hpke_aead/index.html">AEAD</a> for details on the algorithms.</p>
<h2 id="api-considerations"><a href="#api-considerations">API Considerations</a></h2>
<p>This section documents considerations for interfaces to implementations of HPKE.
This includes error handling considerations and recommendations that improve
interoperability when HPKE is used in applications.</p>
<h3 id="auxiliary-authenticated-application-information"><a href="#auxiliary-authenticated-application-information">Auxiliary Authenticated Application Information</a></h3>
<p>HPKE has two places at which applications can specify auxiliary authenticated information:
(1) during context construction via the Setup <code>info</code> parameter, and (2) during Context
operations, i.e., with the <code>aad</code> parameter for <code>Open()</code> and <code>Seal()</code>, and the <code>exporter_context</code> parameter
for <code>Export()</code>. Application information applicable to multiple operations on a single Context
should use the Setup <code>info</code> parameter. This avoids redundantly processing this information for
each Context operation. In contrast, application information that varies on a per-message basis
should be specified via the Context APIs (<code>Seal()</code>, <code>Open()</code>, or <code>Export()</code>).</p>
<p>Applications that only use the single-shot APIs described in {{single-shot-apis}} should use the
Setup <code>info</code> parameter for specifying auxiliary authenticated information. Implementations which
only expose single-shot APIs should not allow applications to use both Setup <code>info</code> and Context
<code>aad</code> or <code>exporter_context</code> auxiliary information parameters.</p>
<h3 id="errors"><a href="#errors">Errors</a></h3>
<p>The high-level, public HPKE APIs specified in this document are all fallible.</p>
<p>See <a href="../hpke_errors/index.html">Errors</a> for details.</p>
<h2 id="message-encoding"><a href="#message-encoding">Message Encoding</a></h2>
<p>This document does not specify a wire format encoding for HPKE messages. Applications
that adopt HPKE must therefore specify an unambiguous encoding mechanism which includes,
minimally: the encapsulated value <code>enc</code>, ciphertext value(s) (and order if there are
multiple), and any info values that are not implicit. One example of a non-implicit
value is the recipient public key used for encapsulation, which may be needed if a
recipient has more than one public key.</p>
<p>The AEAD interface used in this document is based on <a href="https://www.rfc-editor.org/info/rfc5116">RFC5116</a>, which produces and
consumes a single ciphertext value. As discussed in <a href="https://www.rfc-editor.org/info/rfc5116">RFC5116</a>, this ciphertext value
contains the encrypted plaintext as well as any authentication data, encoded in a manner
described by the individual AEAD scheme. Some implementations are not structured in this
way, instead providing a separate ciphertext and authentication tag. When such
AEAD implementations are used in HPKE implementations, the HPKE implementation must combine
these inputs into a single ciphertext value within <a href="fn.HpkeSeal.html"><code>Seal()</code></a>, and parse them out within
<a href="fn.HpkeOpen.html"><code>Open()</code></a>, where the parsing details are defined by the AEAD scheme. For example, with
the AES-GCM schemes specified in this document, the GCM authentication tag is placed in
the last Nt bytes of the ciphertext output.</p>
<h3 id="security-properties"><a href="#security-properties">Security Properties</a></h3>
<p>HPKE has several security goals, depending on the mode of operation,
against active and adaptive attackers that can compromise partial
secrets of senders and recipients. The desired security goals are
detailed below:</p>
<ul>
<li>Message secrecy: Confidentiality of the sender‚Äôs messages against
chosen ciphertext attacks</li>
<li>Export key secrecy: Indistinguishability of each export
secret from a uniformly random bitstring of equal length, i.e.,
<code>Context.Export</code> is a variable-length PRF</li>
<li>Sender authentication: Proof of sender origin for PSK, Auth, and
AuthPSK modes</li>
</ul>
<p>These security goals are expected to hold for any honest sender and
honest recipient keys, as well as if the honest sender and honest
recipient keys are the same.</p>
<p>HPKE mitigates malleability problems (called benign malleability <a href="https://secg.org/sec1-v2.pdf">SECG SEC 1</a>) in prior
public key encryption standards based on ECIES by including all public keys in the
context of the key schedule.</p>
<p>HPKE does not provide forward secrecy with respect to recipient compromise.
In the Base and Auth modes, the secrecy properties are only expected to
hold if the recipient private key <code>skR</code> is not compromised at any point
in time. In the PSK and AuthPSK modes, the secrecy properties are
expected to hold if the recipient private key <code>skR</code> and the pre-shared key
are not both compromised at any point in time. See <a href="#application-embedding-and-non-goals">the non-goals section</a> for more
details.</p>
<p>In the Auth mode, sender authentication is generally expected to hold if
the sender private key <code>skS</code> is not compromised at the time of message
reception. In the AuthPSK mode, sender authentication is generally
expected to hold if at the time of message reception, the sender private
key skS and the pre-shared key are not both compromised.</p>
<p>Besides forward secrecy and key-compromise impersonation, which are highlighted
in this section because of their particular cryptographic importance, HPKE
has other non-goals that are described in <a href="#application-embedding-and-non-goals">the non-goals section</a>: no tolerance of
message reordering or loss, no downgrade or replay prevention, no hiding of the
plaintext length, no protection against bad ephemeral randomness. <a href="#application-embedding-and-non-goals">The non-goals section</a>
suggests application-level mitigations for some of them.</p>
<h4 id="key-compromise-impersonation"><a href="#key-compromise-impersonation">Key-Compromise Impersonation</a></h4>
<p>The DHKEM variants defined in this document are
vulnerable to key-compromise impersonation attacks <a href="https://doi.org/10.1007/bfb0024447">BJM97</a>,
which means that sender authentication cannot be expected to hold in the
Auth mode if the recipient private key <code>skR</code> is compromised, and in the
AuthPSK mode if the pre-shared key and the recipient private key <code>skR</code> are
both compromised. NaCl‚Äôs <code>box</code> interface <a href="https://nacl.cr.yp.to/box.html">NaCl</a> has the same issue. At
the same time, this enables repudiability.</p>
<p>As shown by <a href="https://eprint.iacr.org/2020/1499">ABHKLR20</a>, key-compromise impersonation attacks are generally possible on HPKE
because KEM ciphertexts are not bound to HPKE messages. An adversary who
knows a recipient‚Äôs private key can decapsulate an observed KEM ciphertext,
compute the key schedule, and encrypt an arbitrary message that the recipient
will accept as coming from the original sender. Importantly, this is possible even
with a KEM that is resistant to key-compromise impersonation attacks. As a
result, mitigating this issue requires fundamental changes that are out-of-scope
of this specification.</p>
<p>Applications that require resistance against key-compromise impersonation
SHOULD take extra steps to prevent this attack. One possibility is to
produce a digital signature over <code>(enc, ct)</code> tuples using a sender‚Äôs
private key ‚Äì where <code>ct</code> is an AEAD ciphertext produced by the single-shot
or multi-shot API, and <code>enc</code> the corresponding KEM encapsulated key.</p>
<p>Given these properties, pre-shared keys strengthen both the authentication and the
secrecy properties in certain adversary models. One particular example in which
this can be useful is a hybrid quantum setting: if a
non-quantum-resistant KEM used with HPKE is broken by a
quantum computer, the security properties are preserved through the use
of a pre-shared key. As described in <a href="https://www.rfc-editor.org/info/rfc8696">RFC8696</a> Section 7 this
assumes that the pre-shared key has not been compromised.</p>
<h4 id="computational-analysis"><a href="#computational-analysis">Computational Analysis</a></h4>
<p>It is shown in <a href="https://eprint.iacr.org/2001/108">CS01</a> that a hybrid public-key encryption scheme of
essentially the same form as the Base mode described here is
IND-CCA2-secure as long as the underlying KEM and AEAD schemes are
IND-CCA2-secure. Moreover, it is shown in <a href="https://eprint.iacr.org/2006/265">HHK06</a> that IND-CCA2 security
of the KEM and the data encapsulation mechanism are necessary conditions
to achieve IND-CCA2 security for hybrid public-key encryption.
The main difference between the scheme proposed in <a href="https://eprint.iacr.org/2001/108">CS01</a>
and the Base mode in this document (both named HPKE) is that we interpose
some KDF calls between the KEM and the AEAD. Analyzing the HPKE Base mode
instantiation in this document therefore requires verifying that the
additional KDF calls do not cause the IND-CCA2 property to fail, as
well as verifying the additional export key secrecy property.</p>
<p>Analysis of the PSK, Auth, and AuthPSK modes defined in this document
additionally requires verifying the sender authentication property.
While the PSK mode just adds supplementary keying material to the key
schedule, the Auth and AuthPSK modes make use of a non-standard
authenticated KEM construction. Generally, the authenticated modes of
HPKE can be viewed and analyzed as flavors of signcryption <a href="https://doi.org/10.1007/978-3-540-89411-7">SigncryptionDZ10</a>.</p>
<p>A preliminary computational analysis of all HPKE modes has been done
in <a href="https://eprint.iacr.org/2020/243">HPKEAnalysis</a>, indicating asymptotic security for the case where
the KEM is DHKEM, the AEAD is any IND-CPA and INT-CTXT-secure scheme,
and the DH group and KDF satisfy the following conditions:</p>
<ul>
<li>DH group: The gap Diffie-Hellman (GDH) problem is hard in the
appropriate subgroup <a href="https://link.springer.com/content/pdf/10.1007/3-540-44586-2_8.pdf">GAP</a>.</li>
<li><code>Extract()</code> and <code>Expand()</code>: <code>Extract()</code> can be modeled as a random oracle.
<code>Expand()</code> can be modeled as a pseudorandom function, wherein the first
argument is the key.</li>
</ul>
<p>In particular, the KDFs and DH groups defined in this document (see
<a href="../hpke_kdf/enum.KDF.html">kdf-ids</a> and <a href="../hpke_kem/enum.KEM.html">kem-ids</a>) satisfy these properties when used as
specified. The analysis in <a href="https://eprint.iacr.org/2020/243">HPKEAnalysis</a> demonstrates that under these
constraints, HPKE continues to provide IND-CCA2 security, and provides
the additional properties noted above. Also, the analysis confirms the
expected properties hold under the different key compromise cases
mentioned above. The analysis considers a sender that sends one message
using the encryption context, and additionally exports two independent
secrets using the secret export interface.</p>
<p>The table below summarizes the main results from <a href="https://eprint.iacr.org/2020/243">HPKEAnalysis</a>. N/A
means that a property does not apply for the given mode, whereas <code>y</code> means
the given mode satisfies the property.</p>
<div><table><thead><tr><th style="text-align: left">Variant</th><th style="text-align: center">Message Sec.</th><th style="text-align: center">Export Sec.</th><th style="text-align: center">Sender Auth.</th></tr></thead><tbody>
<tr><td style="text-align: left">Base</td><td style="text-align: center">y</td><td style="text-align: center">y</td><td style="text-align: center">N/A</td></tr>
<tr><td style="text-align: left">PSK</td><td style="text-align: center">y</td><td style="text-align: center">y</td><td style="text-align: center">y</td></tr>
<tr><td style="text-align: left">Auth</td><td style="text-align: center">y</td><td style="text-align: center">y</td><td style="text-align: center">y</td></tr>
<tr><td style="text-align: left">AuthPSK</td><td style="text-align: center">y</td><td style="text-align: center">y</td><td style="text-align: center">y</td></tr>
</tbody></table>
</div>
<p>If non-DH-based KEMs are to be used with HPKE, further analysis will be
necessary to prove their security. The results from <a href="https://eprint.iacr.org/2001/108">CS01</a> provide
some indication that any IND-CCA2-secure KEM will suffice here, but are
not conclusive given the differences in the schemes.</p>
<p>A detailed computational analysis of HPKE‚Äôs Auth mode single-shot
encryption API has been done in <a href="https://eprint.iacr.org/2020/1499">ABHKLR20</a>.
The paper defines security notions for authenticated
KEMs and for authenticated public key encryption, using the outsider and
insider security terminology known from signcryption <a href="https://doi.org/10.1007/978-3-540-89411-7">SigncryptionDZ10</a>.
The analysis proves that DHKEM‚Äôs <a href="../hpke_kem/fn.AuthEncap.html"><code>AuthEncap()</code></a>/<a href="../hpke_kem/fn.AuthDecap.html"><code>AuthDecap()</code></a> interface
fulfills these notions for all Diffie-Hellman groups specified in this document,
and indicates exact security bounds, under the assumption that the
gap Diffie-Hellman (GDH) problem is hard in the appropriate subgroup <a href="https://link.springer.com/content/pdf/10.1007/3-540-44586-2_8.pdf">GAP</a>,
and that HKDF can be modeled as a random oracle.</p>
<p>Further, <a href="https://eprint.iacr.org/2020/1499">ABHKLR20</a> proves composition theorems, showing that HPKE‚Äôs
Auth mode fulfills the security notions of authenticated public key encryption
for all KDFs and AEAD schemes specified in this document, given any
authenticated KEM satisfying the previously defined security notions
for authenticated KEMs. The theorems assume that the KEM is perfectly correct;
they could easily be adapted to work with KEMs that have a non-zero but negligible
probability for decryption failure. The assumptions on the KDF are that <code>Extract()</code>
and <code>Expand()</code> can be modeled as pseudorandom functions wherein the first
argument is the key, respectively. The assumption for the AEAD is
IND-CPA and IND-CTXT security.</p>
<p>In summary, the analysis in <a href="https://eprint.iacr.org/2020/1499">ABHKLR20</a> proves that the single-shot encryption API of HPKE‚Äôs
Auth mode satisfies the desired message confidentiality and sender
authentication properties listed at the beginning of this section;
it does not consider multiple messages, nor the secret export API.</p>
<h4 id="post-quantum-security"><a href="#post-quantum-security">Post-Quantum Security</a></h4>
<p>All of <a href="https://eprint.iacr.org/2001/108">CS01</a>, <a href="https://eprint.iacr.org/2020/243">HPKEAnalysis</a>, and <a href="https://eprint.iacr.org/2020/1499">ABHKLR20</a> are premised on
classical security models and assumptions, and do not consider
adversaries capable of quantum computation. A full proof of post-quantum
security would need to take appropriate security models and assumptions
into account, in addition to simply using a post-quantum KEM. However,
the composition theorems from <a href="https://eprint.iacr.org/2020/1499">ABHKLR20</a> for HPKE‚Äôs Auth mode only make
standard assumptions (i.e., no random oracle assumption) that are expected
to hold against quantum adversaries (although with slightly worse bounds).
Thus, these composition theorems, in combination with a post-quantum-secure
authenticated KEM, guarantee the post-quantum security of HPKE‚Äôs Auth mode.</p>
<p>In future work, the analysis from <a href="https://eprint.iacr.org/2020/1499">ABHKLR20</a> can be extended to cover
HPKE‚Äôs other modes and desired security properties.
The hybrid quantum-resistance property described above, which is achieved
by using the PSK or AuthPSK mode, is not proven in <a href="https://eprint.iacr.org/2020/243">HPKEAnalysis</a> because
this analysis requires the random oracle model; in a quantum
setting, this model needs adaption to, for example, the quantum random
oracle model.</p>
<h3 id="pre-shared-key-recommendations"><a href="#pre-shared-key-recommendations">Pre-Shared Key Recommendations</a></h3>
<p>In the PSK and AuthPSK modes, the PSK MUST have at least 32 bytes of
entropy and SHOULD be of length <a href="../hpke_kdf/fn.Nh.html"><code>Nh</code></a> bytes or longer. Using a PSK longer than
32 bytes but shorter than <a href="../hpke_kdf/fn.Nh.html"><code>Nh</code></a> bytes is permitted.</p>
<p>HPKE is specified to use HKDF as key derivation function. HKDF is not
designed to slow down dictionary attacks, see <a href="https://www.rfc-editor.org/info/rfc5869">RFC5869</a>. Thus, HPKE‚Äôs
PSK mechanism is not suitable for use with a low-entropy password as the
PSK: in scenarios in which the adversary knows the KEM shared secret
<code>shared_secret</code> and has access to an oracle that allows to distinguish between
a good and a wrong PSK, it can perform PSK-recovering attacks. This oracle
can be the decryption operation on a captured HPKE ciphertext or any other
recipient behavior which is observably different when using a wrong PSK.
The adversary knows the KEM shared secret <code>shared_secret</code> if it knows all
KEM private keys of one participant. In the PSK mode this is trivially
the case if the adversary acts as sender.</p>
<p>To recover a lower entropy PSK, an attacker in this scenario can trivially
perform a dictionary attack. Given a set <code>S</code> of possible PSK values, the
attacker generates an HPKE ciphertext for each value in <code>S</code>, and submits
the resulting ciphertexts to the oracle to learn which PSK is being used by
the recipient. Further, because HPKE uses AEAD schemes that are not key-committing,
an attacker can mount a partitioning oracle attack <a href="https://eprint.iacr.org/2020/1491">LGR20</a> which can recover
the PSK from a set of <code>S</code> possible PSK values, with |S| = m*k, in roughly
m + log k queries to the oracle using ciphertexts of length proportional to
k, the maximum message length in blocks. (Applying the multi-collision algorithm from
<a href="https://eprint.iacr.org/2020/1491">LGR20</a> requires a small adaptation to the algorithm wherein the appropriate nonce
is computed for each candidate key. This modification adds one call to HKDF per key.
The number of partitioning oracle queries remains unchanged.) As a result, the PSK
must therefore be chosen with sufficient entropy so that m + log k is prohibitive for
attackers (e.g., 2^128). Future specifications can define new AEAD algorithms which
are key-committing.</p>
<h3 id="domain-separation"><a href="#domain-separation">Domain Separation</a></h3>
<p>HPKE allows combining a DHKEM variant <code>DHKEM(Group, KDF')</code> and a KDF
such that both KDFs are instantiated by the same KDF. By design, the
calls to <code>Extract()</code> and <code>Expand()</code> inside DHKEM and the remainder of
HPKE use separate input domains. This justifies modeling them as
independent functions even if instantiated by the same KDF.
This domain separation between DHKEM and the remainder of HPKE is achieved by
the <code>suite_id</code> values in <code>LabeledExtract()</code> and <code>LabeledExpand()</code>:
The values used (<code>KEM...</code> in DHKEM and <code>HPKE...</code> in the remainder of HPKE)
are prefix-free (a set is prefix-free if no element is a prefix of
another within the set).</p>
<p>Future KEM instantiations MUST ensure, should <code>Extract()</code> and
<code>Expand()</code> be used internally, that they can be modeled as functions
independent from the invocations of <code>Extract()</code> and <code>Expand()</code> in the
remainder of HPKE. One way to ensure this is by using <code>LabeledExtract()</code>
and <code>LabeledExpand()</code> with a <code>suite_id</code> as defined in [base-crypto],
which will ensure input domain separation as outlined above.
Particular attention needs to
be paid if the KEM directly invokes functions that are used internally
in HPKE‚Äôs <code>Extract()</code> or <code>Expand()</code>, such as <code>Hash()</code> and <code>HMAC()</code> in the case of HKDF.
It MUST be ensured that inputs to these invocations cannot collide with
inputs to the internal invocations of these functions inside <code>Extract()</code> or
<code>Expand()</code>. In HPKE‚Äôs <code>KeySchedule()</code> this is avoided by using <code>Extract()</code> instead of
<code>Hash()</code> on the arbitrary-length inputs <code>info</code> and <code>psk_id</code>.</p>
<p>The string literal ‚ÄúHPKE-v1‚Äù used in <code>LabeledExtract()</code> and <code>LabeledExpand()</code>
ensures that any secrets derived in HPKE are bound to the scheme‚Äôs name
and version, even when possibly derived from the same Diffie-Hellman or
KEM shared secret as in another scheme or version.</p>
<h3 id="application-embedding-and-non-goals"><a href="#application-embedding-and-non-goals">Application Embedding and Non-Goals</a></h3>
<p>HPKE is designed to be a fairly low-level mechanism. As a result, it assumes
that certain properties are provided by the application in which HPKE is
embedded, and leaves certain security properties to be provided by other
mechanisms. Otherwise said, certain properties are out-of-scope for HPKE.</p>
<h4 id="message-order-and-message-loss"><a href="#message-order-and-message-loss">Message Order and Message Loss</a></h4>
<p>The primary requirement that HPKE imposes on applications is the requirement
that ciphertexts MUST be presented to <code>ContextR.Open()</code> in the same order in
which they were generated by <code>ContextS.Seal()</code>. When the single-shot API is
used (see [single-shot-apis]), this is trivially true (since there is only
ever one ciphertext. Applications that allow for multiple invocations of
<code>Open()</code> / <code>Seal()</code> on the same context MUST enforce the ordering property
described above.</p>
<p>Ordering requirements of this character are usually fulfilled by providing a
sequence number in the framing of encrypted messages. Whatever information is
used to determine the ordering of HPKE-encrypted messages SHOULD be included in
the AAD passed to <code>ContextS.Seal()</code> and <code>ContextR.Open()</code>. The specifics of
this scheme are up to the application.</p>
<p>HPKE is not tolerant of lost messages. Applications MUST be able to detect when
a message has been lost. When an unrecoverable loss is detected, the application MUST discard
any associated HPKE context.</p>
<h4 id="downgrade-prevention"><a href="#downgrade-prevention">Downgrade Prevention</a></h4>
<p>HPKE assumes that the sender and recipient agree on what algorithms to use.
Depending on how these algorithms are negotiated, it may be possible for an
intermediary to force the two parties to use suboptimal algorithms.</p>
<h4 id="replay-protection"><a href="#replay-protection">Replay Protection</a></h4>
<p>The requirement that ciphertexts be presented to the <code>ContextR.Open()</code> function
in the same order they were generated by <code>ContextS.Seal()</code> provides a degree of
replay protection within a stream of ciphertexts resulting from a given context.
HPKE provides no other replay protection.</p>
<h4 id="forward-secrecy"><a href="#forward-secrecy">Forward Secrecy</a></h4>
<p>HPKE ciphertexts are not forward secret with respect to recipient compromise
in any mode. This means that compromise of long-term recipient secrets allows
an attacker to decrypt past ciphertexts encrypted under said secrets. This is because
only long-term secrets are used on the side of the recipient.</p>
<p>HPKE ciphertexts are forward secret with respect to sender compromise in all
modes. This is because ephemeral randomness is used on the sender‚Äôs side, which
is supposed to be erased directly after computation of the KEM shared secret and
ciphertext.</p>
<h4 id="bad-ephemeral-randomness"><a href="#bad-ephemeral-randomness">Bad Ephemeral Randomness</a></h4>
<p>If the randomness used for KEM encapsulation is bad ‚Äì i.e. of low entropy or
compromised because of a broken or subverted random number generator ‚Äì the
confidentiality guarantees of HPKE degrade significantly. In Base mode,
confidentiality guarantees can be lost completely; in the other modes, at least forward secrecy with
respect to sender compromise can be lost completely.</p>
<p>Such a situation could also lead to the reuse of the same KEM shared secret
and thus to the reuse of same key-nonce pairs for the AEAD.
The AEADs specified in this document are not secure
in case of nonce reuse. This attack vector is particularly relevant in
authenticated modes because knowledge of the ephemeral randomness is not
enough to derive <code>shared_secret</code> in these modes.</p>
<p>One way for applications to mitigate the impacts of bad ephemeral randomness is
to combine ephemeral randomness with a local long-term secret that has been
generated securely, as described in <a href="https://www.rfc-editor.org/info/rfc8937">RFC8937</a>.</p>
<h4 id="hiding-plaintext-length"><a href="#hiding-plaintext-length">Hiding Plaintext Length</a></h4>
<p>AEAD ciphertexts produced by HPKE do not hide the plaintext length. Applications
requiring this level of privacy should use a suitable padding mechanism. See
<a href="https://datatracker.ietf.org/doc/draft-ietf-tls-esni/">tls-esni</a> and <a href="https://www.rfc-editor.org/info/rfc8467">RFC8467</a> for examples of protocol-specific
padding policies.</p>
<h3 id="bidirectional-encryption"><a href="#bidirectional-encryption">Bidirectional Encryption</a></h3>
<p>HPKE encryption is unidirectional from sender
to recipient. Applications that require bidirectional encryption can derive
necessary keying material with the Secret Export interface.
The type and length of such keying material depends on the application use
case.</p>
<p>As an example, if an application needs AEAD encryption from recipient to
sender, it can derive a key and nonce from the corresponding HPKE context
as follows:</p>
<div class="example-wrap"><pre class="language-text"><code>key = context.Export(&quot;response key&quot;, Nk)
nonce = context.Export(&quot;response nonce&quot;, Nn)</code></pre></div>
<p>In this example, the length of each secret is based on the AEAD algorithm
used for the corresponding HPKE context.</p>
<p>Note that HPKE‚Äôs limitations with regard to sender authentication become limits
on recipient authentication in this context. In particular, in the Base mode,
there is no authentication of the remote party at all. Even in the Auth mode,
where the remote party has proven that they hold a specific private key, this
authentication is still subject to Key-Compromise Impersonation, as discussed
in <a href="#key-compromise-impersonation">kci</a>.</p>
<h3 id="metadata-protection"><a href="#metadata-protection">Metadata Protection</a></h3>
<p>The authenticated modes of HPKE (PSK, Auth, AuthPSK) require that the recipient
know what key material to use for the sender. This can be signaled in
applications by sending the PSK ID (<code>psk_id</code> above) and/or the sender‚Äôs public
key (<code>pkS</code>). However, these values themselves might be considered sensitive,
since in a given application context, they might identify the sender.</p>
<p>An application that wishes to protect these metadata values without requiring
further provisioning of keys can use an additional instance of HPKE, using the
unauthenticated Base mode. Where the application might have sent <code>(psk_id, pkS, enc, ciphertext)</code> before, it would now send <code>(enc2, ciphertext2, enc, ciphertext)</code>,
where <code>(enc2, ciphertext2)</code> represent the encryption of the <code>psk_id</code> and <code>pkS</code>
values.</p>
<p>The cost of this approach is an additional KEM operation each for the sender and
the recipient. A potential lower-cost approach (involving only symmetric
operations) would be available if the nonce-protection schemes in <a href="http://dx.doi.org/10.1007/978-3-030-26948-7_9">BNT19</a>
could be extended to cover other metadata. However, this construction would
require further analysis.</p>
<h2 id="hacspec-implementation-considerations"><a href="#hacspec-implementation-considerations">hacspec implementation considerations</a></h2>
<p>When defining HPKE in hacspec there are a number of considerations that have an
impact on the way the code looks.</p>
<p>The hacspec code is as close to the RFC pseudocode as possible.
But some changes are necessary.</p>
<h4 id="randomness"><a href="#randomness">Randomness</a></h4>
<p>hacspec does not allow to draw randomness.
It is therefore necessary to pass in randomness every time it is needed.</p>
<p>This approach is pretty close to the way this would be implemented in native Rust
where a random-number generator is passed in and used to generate randomness.</p>
<h4 id="configuration-parameters"><a href="#configuration-parameters">Configuration Parameters</a></h4>
<p>The HPKE RFC makes most of the configuration implicit to the functions rather than
passing the algorithm identifiers around.
Because the hacspec implementation has to know which algorithm to pick, this is
of course not possible here.</p>
<p>HPKE hacspec functions take either an <a href="struct.HPKEConfig.html" title="HPKEConfig"><code>HPKEConfig</code></a> object with all algorithms
in it or the specific algorithm identifier needed for the operation.</p>
<h4 id="naming"><a href="#naming">Naming</a></h4>
<p>The HPKE RFC uses, in some cases, names that are impossible to use in hacspec
because they are keywords or contain illegal characters.
Further does hacspec not support member functions.</p>
<p>We therefore replace <code>.</code> in function calls such as <code>Context.Export</code> with an underscore,
i.e. write <code>Context_Export</code>.
Keywords such as <code>open</code> are replaced with a semantically equivalent, i.e. <code>HpkeOpen</code>.</p>
<h4 id="secret-bytes"><a href="#secret-bytes">Secret bytes</a></h4>
<p>hacspec has the notion of secret integers that can‚Äôt be used for certain operations
and should enforce secret-independent computation time.</p>
<p>For simplicity the hacspec HPKE implementation uses secret bytes everywhere even
if not necessary, e.g. for cipher texts.</p>
<h4 id="errors-1"><a href="#errors-1">Errors</a></h4>
<p>While the RFC defines a set of errors it does not always define which errors
are raised.
For example, it leaves open whether implementations convert errors from the
Diffie-Hellman operations into KEM errors (<code>EncapError</code>/<code>DecapError</code>) or not.</p>
<p>With the specific implementation in hacspec here the errors are clearly defined.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.HPKECiphertext.html" title="hpke::HPKECiphertext struct">HPKECiphertext</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.HPKEConfig.html" title="hpke::HPKEConfig struct">HPKEConfig</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.HPKEKeyPair.html" title="hpke::HPKEKeyPair struct">HPKEKeyPair</a></div><div class="item-right docblock-short"></div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Mode.html" title="hpke::Mode enum">Mode</a></div><div class="item-right docblock-short"><p>A one-byte value indicating the HPKE mode, defined in the following table.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ComputeNonce.html" title="hpke::ComputeNonce fn">ComputeNonce</a></div><div class="item-right docblock-short"><p>Compute Nonce</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ContextR_Open.html" title="hpke::ContextR_Open fn">ContextR_Open</a></div><div class="item-right docblock-short"><p>Stateful open.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ContextS_Seal.html" title="hpke::ContextS_Seal fn">ContextS_Seal</a></div><div class="item-right docblock-short"><p>Encryption and Decryption</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.Context_Export.html" title="hpke::Context_Export fn">Context_Export</a></div><div class="item-right docblock-short"><p>Secret Export</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.HpkeOpen.html" title="hpke::HpkeOpen fn">HpkeOpen</a></div><div class="item-right docblock-short"><p>Decryption</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.HpkeSeal.html" title="hpke::HpkeSeal fn">HpkeSeal</a></div><div class="item-right docblock-short"><p>Encryption</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.IncrementSeq.html" title="hpke::IncrementSeq fn">IncrementSeq</a></div><div class="item-right docblock-short"><p>Increment Sequence</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.KeySchedule.html" title="hpke::KeySchedule fn">KeySchedule</a></div><div class="item-right docblock-short"><p>Creating the Encryption Context</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ReceiveExport.html" title="hpke::ReceiveExport fn">ReceiveExport</a></div><div class="item-right docblock-short"><p>‚Äúsingle-shot‚Äù secret export receiver</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SendExport.html" title="hpke::SendExport fn">SendExport</a></div><div class="item-right docblock-short"><p>‚Äúsingle-shot‚Äù secret export sender</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SetupAuthPSKR.html" title="hpke::SetupAuthPSKR fn">SetupAuthPSKR</a></div><div class="item-right docblock-short"><p>Authentication using both a PSK and an Asymmetric Key - Receiver</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SetupAuthPSKS.html" title="hpke::SetupAuthPSKS fn">SetupAuthPSKS</a></div><div class="item-right docblock-short"><p>Authentication using both a PSK and an Asymmetric Key - Sender</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SetupAuthR.html" title="hpke::SetupAuthR fn">SetupAuthR</a></div><div class="item-right docblock-short"><p>Authentication using an Asymmetric Key - Receiver</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SetupAuthS.html" title="hpke::SetupAuthS fn">SetupAuthS</a></div><div class="item-right docblock-short"><p>Authentication using an Asymmetric Key - Sender</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SetupBaseR.html" title="hpke::SetupBaseR fn">SetupBaseR</a></div><div class="item-right docblock-short"><p>Encryption to a Public Key - Receiver</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SetupBaseS.html" title="hpke::SetupBaseS fn">SetupBaseS</a></div><div class="item-right docblock-short"><p>Encryption to a Public Key - Sender</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SetupPSKR.html" title="hpke::SetupPSKR fn">SetupPSKR</a></div><div class="item-right docblock-short"><p>Authentication using a Pre-Shared Key - Receiver</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.SetupPSKS.html" title="hpke::SetupPSKS fn">SetupPSKS</a></div><div class="item-right docblock-short"><p>Authentication using a Pre-Shared Key - Sender</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.VerifyPSKInputs.html" title="hpke::VerifyPSKInputs fn">VerifyPSKInputs</a></div><div class="item-right docblock-short"><p>Creating the Encryption Context</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.AdditionalData.html" title="hpke::AdditionalData type">AdditionalData</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Ciphertext.html" title="hpke::Ciphertext type">Ciphertext</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.ContextResult.html" title="hpke::ContextResult type">ContextResult</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.EmptyResult.html" title="hpke::EmptyResult type">EmptyResult</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.HpkePrivateKey.html" title="hpke::HpkePrivateKey type">HpkePrivateKey</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.HpkePublicKey.html" title="hpke::HpkePublicKey type">HpkePublicKey</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.KemOutput.html" title="hpke::KemOutput type">KemOutput</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Psk.html" title="hpke::Psk type">Psk</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.PskId.html" title="hpke::PskId type">PskId</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.SenderContextResult.html" title="hpke::SenderContextResult type">SenderContextResult</a></div><div class="item-right docblock-short"></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="hpke" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0-nightly (495b21669 2022-07-03)" ></div>
</body></html>